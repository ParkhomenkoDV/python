Бывает, что компания ищет дата-сайентиста, а на самом деле ей нужен Python-разработчик. Поэтому при подготовке к собеседованию есть смысл освежить в памяти информацию по Python, а не только штудировать алгоритмы.

Команда Mail.ru Cloud Solutions перевела статью разработчика, который не раз попадал в такую ситуацию и на основе своего опыта составил список из 53 вопросов и ответов для подготовки к собеседованию. Большинство исследователей данных пишут много кода, поэтому такой список пригодится и дата-сайентистам, и инженерам. Он будет полезен и для соискателей, и для тех, кто проводит собеседования, и для тех, кто просто изучает Python.

Вопросы идут в случайном порядке. Поехали.

1. В чем разница между списком и кортежем?

Мне задавали этот вопрос буквально на каждом собеседовании по Python/data science. Выучите ответ как свои пять пальцев:

Список можно изменить после создания.
Кортеж нельзя изменить после создания.
Список упорядочен. Он представляет собой упорядоченные последовательности объектов, как правило, одного и того же типа. Например, все имена пользователей упорядочены по дате создания: ["Seth", "Ema", "Eli"].
У кортежа есть структура. В каждом индексе могут сосуществовать различные типы данных. Например, такая запись базы данных в памяти: (2, "Ema", "2020–04–16") # id, name, created_at.

2. Как выполняется интерполяция строк?

Без импорта класса Template есть три способа интерполяции строк:

name = 'Chris'

# 1. f strings
print(f'Hello {name}')

# 2. % operator
print('Hey %s %s' % (name, name))

# 3. format
print(
 "My name is {}".format((name))
)

3. В чем разница между is и ==?

Когда я был начинающим разработчиком, то не видел разницы… привет, баги. Так что для протокола: is проверяет идентичность, а == проверяет равенство.

Рассмотрим пример. Создайте несколько списков и назначьте им имена. Обратите внимание, что ниже b указывает на тот же объект, что и a:

a = [1,2,3]
b = a
c = [1,2,3]

Проверьте равенство и обратите внимание, что все объекты равны:

print(a == b)
print(a == c)
#=> True
#=> True

Но являются ли все они идентичными? Нет:

print(a is b)
print(a is c)
#=> True
#=> False

Можем проверить это, распечатав их идентификаторы объектов:

print(id(a))
print(id(b))
print(id(c))
#=> 4369567560
#=> 4369567560
#=> 4369567624

Идентификатор c отличается от идентификатора a и b.

4. Что такое декоратор?

Еще один вопрос, который мне задавали на каждом собеседовании. Тема заслуживает отдельной статьи, но для базовой подготовки достаточно просто написать собственный пример.

Декоратор позволяет добавить новую функциональность к существующей функции. Это делается следующим образом. Функция передается декоратору, а он выполняет и существующий, и дополнительный код.

Напишем декоратор, который записывает в журнал вызовы другой функции.

Напишите функцию декоратора. В качестве аргумента он принимает функцию func. Декоратор определяет функцию log_function_called, которая вызывает func() и выполняет некоторый код print(f'{func} called.'). Затем возвращает определенную им функцию:

def logging(func):
 def log_function_called():
   print(f'{func} called.')
   func()
 return log_function_called

Напишем другие функции, к которым добавим декоратор (потом, не сейчас):

def my_name():
  print('chris')
def friends_name():
  print('naruto')
my_name()
friends_name()
#=> chris
#=> naruto

Теперь добавим декоратор к ним обоим:

@logging
def my_name():
 print('chris')

@logging
def friends_name():
 print('naruto')

my_name()
friends_name()
#=> <function my_name at 0x10fca5a60> called.
#=> chris
#=> <function friends_name at 0x10fca5f28> called.
#=> naruto

Теперь легко добавить ведение журнала в любую функцию, которую мы пишем. Достаточно написать перед ней @logging.

5. Объясните функцию range

Range генерирует список целых чисел. Ее можно использовать тремя способами.

Функция принимает от одного до трех аргументов. Обратите внимание, что я завернул каждый пример в список, чтобы видеть генерируемые значения.

range(stop) — генерирует целые числа от 0 до целого числа stop:

[i for i in range(10)]
#=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

range(start, stop) — генерирует целые числа от start до stop:

[i for i in range(2,10)]
#=> [2, 3, 4, 5, 6, 7, 8, 9]

range(start, stop, step) — генерирует целые числа от start до stop с интервалами step:

[i for i in range(2,10,2)]
#=> [2, 4, 6, 8]

Серж Боремчук предложил более подходящий способ:

list(range(2,10,2))
#=> [2, 4, 6, 8]

6. Определите класс car с двумя атрибутами: color и speed. Затем создайте экземпляр и верните speed

Вот как это сделать:

class Car :
    def __init__(self, color, speed):
        self.color = color
        self.speed = speed
car = Car('red','100mph')
car.speed
#=> '100mph'

7. В чем разница между методами экземпляра, класса и статическими методами в Python?

Методы экземпляра: принимают параметр self и относятся к определенному экземпляру класса.

Статические методы: используют декоратор @staticmethod, не связаны с конкретным экземпляром и являются автономными (атрибуты класса или экземпляра не изменяются).

Методы класса: принимают параметр cls, можно изменить сам класс.

Проиллюстрируем разницу на вымышленном классе CoffeeShop:

class CoffeeShop:
    specialty = 'espresso'

    def __init__(self, coffee_price):
        self.coffee_price = coffee_price
  
    # instance method
    def make_coffee(self):
        print(f'Making {self.specialty} for ${self.coffee_price}')
 
    # static method    
    @staticmethod
    def check_weather():
        print('Its sunny')

    # class method
    @classmethod
    def change_specialty(cls, specialty):
        cls.specialty = specialty
        print(f'Specialty changed to {specialty}')

У класса CoffeeShop есть атрибут specialty (фирменный напиток), установленный по умолчанию в значение 'espresso'. Каждый экземпляр CoffeeShop инициализируется с атрибутом coffee_price. У него также три метода: метод экземпляра, статический метод и метод класса.

Давайте инициализируем экземпляр с атрибутом coffee_price, равным 5. Затем вызовем метод экземпляра make_coffee:

coffee_shop = CoffeeShop('5')
coffee_shop.make_coffee()
#=> Making espresso for $5

Теперь вызовем статический метод. Статические методы не могут изменять состояние класса или экземпляра, поэтому обычно используются для служебных функций, например, сложения двух чисел. Наши проверяют погоду. Говорят, что солнечно. Отлично!

coffee_shop.check_weather()
#=> Its sunny

Теперь используем метод класса для изменения фирменного напитка (specialty), а затем сделаем кофе (make_coffee):

coffee_shop.change_specialty('drip coffee')
#=> Specialty changed to drip coffee

coffee_shop.make_coffee()
#=> Making drip coffee for $5

Обратите внимание, что make_coffee раньше делал эспрессо, а теперь заваривает капельную кофеварку (drip coffee).

8. В чем разница между func и func()?

Вопрос должен проверить ваше понимание, что все функции в Python также являются объектами:

def func():
    print('Im a function')

func
#=> function __main__.func>
func()    
#=> Im a function

func — это представляющий функцию объект, который можно назначить переменной или передать другой функции. Функция func() с круглыми скобками вызывает функцию и возвращает результат.

9. Объясните, как работает функция map

Она возвращает объект (итератор), который перебирает значения, применяя функцию к каждому элементу. В случае необходимости объект можно преобразовать в список:

def add_three(x):
    return x + 3
li = [1,2,3]
list(map(add_three, li))
#=> [4, 5, 6]

Здесь к каждому элементу в списке мы добавляем число 3.

10. Объясните, как работает функция reduce

Это может быть сложновато сразу понять, пока вы не используете ее несколько раз.

reduce принимает функцию и последовательность — и проходит по этой последовательности. На каждой итерации в функцию передаются как текущий элемент, так и выходные данные предыдущего элемента. В конце концов, возвращается одно значение:

from functools import reduce
def add_three(x,y):
    return x + y
li = [1,2,3,5]
reduce(add_three, li)
#=> 11

Возвращается 11, что является суммой 1+2+3+5.

11. Объясните, как работает функция filter

Функция делает буквально то, о чем говорит ее название: она фильтрует элементы в последовательности.

Каждый элемент передается функции, которая включает его в последовательность, если по условию получает True, и отбрасывает в случае False:

def add_three(x):
    if x % 2 == 0:
        return True        
    else:
        return False

li = [1,2,3,4,5,6,7,8]

[i for i in filter(add_three, li)]
#=> [2, 4, 6, 8]

Обратите внимание, как удалены все элементы, которые не делятся на 2.

12. Переменные в Python передаются по ссылке или по значению?

Будьте готовы спуститься в кроличью нору семантики, если загуглите этот вопрос и прочтете несколько первых страниц.

В общем, все имена передаются по ссылке, но в некоторых ячейках памяти хранятся объекты, а в других — указатели на другие ячейки памяти.

name = 'object'

Давайте посмотрим, как это работает со строками. Создадим экземпляр имени и объекта, на который указывают другие имена. Затем удалим первое:

x = 'some text'
y = x
x is y #=> True

del x # удаляем имя 'a' , но не объект в памяти

z = y
y is z #=> True

Мы видим, что все имена указывают на один и тот же объект в памяти, который остался нетронутым после операции удаления имени del x.

Вот еще один интересный пример с функцией:

name = 'text'
def add_chars(str1):
    print( id(str1) ) #=> 4353702856
    print( id(name) ) #=> 4353702856
  
    # новое имя, тот же объект
    str2 = str1
  
    # создаем новое имя (не отличается от предыдущего) и новый объект
    str1 += 's' 
    print( id(str1) ) #=> 4387143328
    
    # объект не изменился
    print( id(str2) ) #=> 4353702856
     
add_chars(name)
print(name) #=>text

Обратите внимание, что добавление буквы s в строку внутри функции создает новое имя — и новый объект тоже. Даже если у нового объекта то же самое имя, что и у существующего.

13. Как развернуть список?

Обратите внимание, что reverse() вызывается в списке и изменяет его. Сама функция не возвращает измененный список:

li = ['a','b','c']

print(li)
li.reverse()
print(li)
#=> ['a', 'b', 'c']
#=> ['c', 'b', 'a']

14. Как работает умножение строк?

Посмотрим результат умножения строки 'cat' на 3:

'cat' * 3
#=> 'catcatcat'

В результате содержимое строки повторяется трижды.

15. Как работает умножение списка?

Посмотрим на результат умножения списка [1,2,3] на 2:

[1,2,3] * 2
#=> [1, 2, 3, 1, 2, 3]

Содержание списка [1,2,3] повторяется дважды.

16. Что означает self в классе?

Self ссылается на экземпляр класса. Так метод может обновлять объект, к которому принадлежит.

Ниже передача self в __init__() дает возможность установить цвет экземпляра при инициализации:

class Shirt:
    def __init__(self, color):
        self.color = color
    
s = Shirt('yellow')
s.color
#=> 'yellow'

17. Как объединить списки в Python?

Списки объединяются при сложении. Обратите внимание, что с массивами так не получается:

a = [1,2]
b = [3,4,5]

a + b
#=> [1, 2, 3, 4, 5]

18. В чем разница между глубокой и мелкой копиями?

Обсудим это в контексте изменяемого объекта — списка. Для неизменяемых объектов глубокое и мелкое (поверхностное) копирование обычно не отличаются.

Рассмотрим три сценария.

I) Поставьте ссылку на исходный объект. Она отсылает новое имя li2 к тому же месту в памяти, на которое указывает li1. Поэтому любое изменение в li1 также происходит с li2:

li1 = [['a'],['b'],['c']]
li2 = li1

li1.append(['d'])
print(li2)
#=> [['a'], ['b'], ['c'], ['d']]

II) Создайте мелкую копию оригинала. Ее можно создать с помощью конструктора list() или mylist.copy().

Мелкая копия создает новый объект, но заполняет его ссылками на оригинал. Таким образом, добавление нового объекта в исходный список li3 не отразится в li4, а вот изменение объектов в li3 — отразится:

li3 = [['a'],['b'],['c']]
li4 = list(li3)

li3.append([4])
print(li4)
#=> [['a'], ['b'], ['c']]

li3[0][0] = ['X']
print(li4)
#=> [[['X']], ['b'], ['c']]

III) Создайте глубокую копию. Это делается с помощью copy.deepcopy(). Оригинал и копия полностью независимы, а изменения в одном не оказывают никакого влияния на другой:

import copy

li5 = [['a'],['b'],['c']]
li6 = copy.deepcopy(li5)

li5.append([4])
li5[0][0] = ['X']
print(li6)
#=> [['a'], ['b'], ['c']]

19. В чем разница между списками и массивами?

Примечание: в стандартной библиотеке Python есть объект array, но здесь мы специально обсуждаем массив из популярной библиотеки Numpy.

Списки в каждом индексе можно заполнять разными типами данных. Массивы требуют однородных элементов.

Арифметические действия в списках добавляют или удаляют элементы из списка. Арифметические действия на массивах соответствуют функциям линейной алгебры.

Массивы используют меньше памяти и обладают значительно большей функциональностью.

20. Как объединить два массива?

Помните, что массивы — это не списки. Это библиотека Numpy и здесь работает линейная алгебра.

Для объединения массивов нужно использовать соответствующую функцию Numpy:

import numpy as np

a = np.array([1,2,3])
b = np.array([4,5,6])

np.concatenate((a,b))
#=> array([1, 2, 3, 4, 5, 6])

21. Что вам нравится в Python?

Примечание: это очень субъективный вопрос, и логично адаптировать ответ в зависимости от того, на какую должность вы претендуете.

Python очень удобочитаем, и есть так называемый «питоновский способ» решения почти любой задачи, то есть самый понятный, ясный и лаконичный код.

Это мне кажется противоположностью Ruby, где часто много способов решить задачу без четких указаний, какой вариант предпочтительнее.

22. Какая ваша любимая библиотека в Python?

Примечание: это тоже субъективно, см. вопрос 21.

При работе с большим количеством данных трудно найти что-то полезнее, чем pandas. С этой библиотекой обработка и визуализация данных становятся проще простого.

23. Назовите изменяемые и неизменяемые объекты

Неизменяемость означает, что состояние нельзя изменить после создания. Примеры: int, float, bool, string и tuple.

Состояние изменяемых объектов можно изменить. Примеры: list, dict и set.

24. Как округлить число до трех десятичных знаков?

Используйте функцию round(value, decimal_places):

a = 5.12345
round(a,3)
#=> 5.123

25. Как разбить список?

Синтаксис функции включает три аргумента: list[start:stop:step], где step — это интервал, через который возвращаются элементы:

a = [0,1,2,3,4,5,6,7,8,9]

print(a[:2])
#=> [0, 1]

print(a[8:])
#=> [8, 9]

print(a[2:8])
#=> [2, 3, 4, 5, 6, 7]

print(a[2:8:2])
#=> [2, 4, 6]

26. Что такое pickle?

Pickle — это модуль сериализации и десериализации объектов в Python.

В примере ниже мы сериализуем и десериализуем список словарей:

import pickle

obj = [
    {'id':1, 'name':'Stuffy'},
    {'id':2, 'name': 'Fluffy'}
]

with open('file.p', 'wb') as f:
    pickle.dump(obj, f)

with open('file.p', 'rb') as f:
    loaded_obj = pickle.load(f)

print(loaded_obj)
#=> [{'id': 1, 'name': 'Stuffy'}, {'id': 2, 'name': 'Fluffy'}]

27. Какая разница между словарями и JSON?

Dict (словарь) — это тип данных Python, представляющий собой набор индексированных, но неупорядоченных пар ключ-значение.

JSON — просто строка, которая следует заданному формату и предназначена для передачи данных.

28. Какие ORM вы использовали в Python?

Технология ORM (object-relational mapping, объектно-реляционное отображение) связывает модели данных (обычно в приложении) с таблицами БД и упрощает транзакции с базой данных.

В контексте Flask обычно используется SQLAlchemy, а у Django собственная ORM.

29. Как работают any() и all()?

Any возвращает true, если хоть один элемент в последовательности соответствует условию, то есть является true.

All возвращает true только в том случае, если условию соответствуют все элементы в последовательности.

a = [False, False, False]
b = [True, False, False]
c = [True, True, True]

print( any(a) )
print( any(b) )
print( any(c) )
#=> False
#=> True
#=> True

print( all(a) )
print( all(b) )
print( all(c) )
#=> False
#=> False
#=> True

30. Где быстрее поиск: в словарях или списках?

Поиск значения в списке занимает O(n) времени, потому что нужно пройти весь список.

Поиск ключа в словаре занимает O(1) времени, потому что это хэш-таблица.

Разница во времени может быть огромной, если значений много, поэтому для производительности обычно рекомендуют словари. Но у них есть другие ограничения, такие как необходимость уникальных ключей.

31. В чем разница между модулем и пакетом?

Модуль — это файл или набор файлов, которые импортируются вместе:

import sklearn

Пакет — это каталог с модулями:

from sklearn import cross_validation

Таким образом, пакеты — это модули, но не все модули являются пакетами.

32. Как увеличить и уменьшить целое число в Python?

Инкремент и декремент можно сделать с помощью += и -=:

value = 5

value += 1
print(value)
#=> 6

value -= 1
value -= 1
print(value)
#=> 4

33. Как вернуть двоичный код целого числа?

Используйте функцию bin():

bin(5)
#=> '0b101'

34. Как удалить из списка дубликаты?

Это можно сделать путем преобразования списка в набор, а затем обратно в список:

a = [1,1,1,2,3]
a = list(set(a))
print(a)
#=> [1, 2, 3]

Обратите внимание, что наборы не обязательно поддерживают порядок следования списка.

35. Как проверить, существует ли значение в списке?

Используйте in:

'a' in ['a','b','c']
#=> True

'a' in [1,2,3]
#=> False

36. В чем разница между append и extend?

append добавляет значения в список, а extend добавляет в список значения из другого списка:

a = [1,2,3]
b = [1,2,3]

a.append(6)
print(a)
#=> [1, 2, 3, 6]

b.extend([4,5])
print(b)
#=> [1, 2, 3, 4, 5]

37. Как получить абсолютное значение целого числа?

Это можно сделать с помощью функции abs():

abs(2)
#=> 2

abs(-2)
#=> 2

38. Как объединить два списка в список кортежей?

Для объединения в список кортежей можно использовать функцию zip, причем не только двух, но трех и более списков.

a = ['a','b','c']
b = [1,2,3]

[(k,v) for k,v in zip(a,b)]
#=> [('a', 1), ('b', 2), ('c', 3)]

39. Как отсортировать словарь по ключам, в алфавитном порядке?

Нельзя «отсортировать» словарь, поскольку словари не поддерживают упорядочение, но можно вернуть отсортированный список кортежей с ключами и значениями из словаря:

d = {'c':3, 'd':4, 'b':2, 'a':1}

sorted(d.items())
#=> [('a', 1), ('b', 2), ('c', 3), ('d', 4)]

40. Как реализуется наследование классов в Python?

В приведенном ниже примере класс Audi является наследником Car. И вместе с этим наследуются методы экземпляра родительского класса:

class Car():
    def drive(self):
        print('vroom')
class Audi(Car):
    pass
audi = Audi()
audi.drive()

41. Как удалить все пробелы из строки?

Можно разделить строку в местах пробелов, а затем снова соединить без пробелов:

s = 'A string with white space'

''.join(s.split())
#=> 'Astringwithwhitespace'

Двое читателей рекомендовали более каноничный способ замены, который следует духу Python, что «явное лучше, чем неявное». Он также быстрее работает, потому что здесь не создается новый объект списка:

s = 'A string with white space'
s.replace(' ', '')
#=> 'Astringwithwhitespace'

42. Почему мы используем enumerate() при итерации последовательности?

enumerate() позволяет отслеживать индекс при итерации последовательности. Это более нативный способ, чем определение и приращение целого числа, представляющего индекс:

li = ['a','b','c','d','e']

for idx,val in enumerate(li):
print(idx, val)
#=> 0 a
#=> 1 b
#=> 2 c
#=> 3 d
#=> 4 e

43. В чем разница между pass, continue и break?

Заглушка pass означает «ничего не делать». Обычно мы используем эту функцию, потому что Python не позволяет создавать класс, функцию или оператор if без кода внутри.

В приведенном ниже примере вылетит ошибка, если внутри i > 3 не будет кода, поэтому мы используем pass:

a = [1,2,3,4,5]
for i in a:
    if i > 3:
        pass
    print(i)
#=> 1
#=> 2
#=> 3
#=> 4
#=> 5

continue отправляет вас к следующему элементу в цикле, останавливая выполнение для текущего элемента. Таким образом, print(i) никогда не получает значения i < 3:

for i in a:
    if i < 3:
        continue
    print(i)
#=> 3
#=> 4
#=> 5

break прерывает цикл, и последовательность больше не повторяется. Таким образом, на цифре 3 цикл прерывается, а этот и следующие элементы не печатаются:

for i in a:
   if i == 3:
       break
   print(i)   
#=> 1
#=> 2

44. Преобразуйте следующий цикл for в генератор списков (list comprehension)

Дан следующий цикл for:

a = [1,2,3,4,5]

a2 = []
for i in a:
     a2.append(i + 1)
print(a2)
#=> [2, 3, 4, 5, 6]

Результат:

a3 = [i+1 for i in a]

print(a3)
#=> [2, 3, 4, 5, 6]

Генератор списка обычно считается более каноническим способом в Python, если он остается понятным.

45. Приведите пример тернарного оператора

Тернарный (условный) оператор — это однострочный оператор if/else.

Синтаксис такой: a if condition else b.

x = 5
y = 10

'greater' if x > 6 else 'less'
#=> 'less'

'greater' if y > 6 else 'less'
#=> 'greater'

46. Проверьте, что в строке только числа

Можно использовать isnumeric():

'123a'.isnumeric()
#=> False

'123'.isnumeric()
#=> True

47. Проверьте, что в строке только буквы

Можно использовать isalpha():

'123a'.isalpha()
#=> False

'a'.isalpha()
#=> True

48. Проверьте, что в строке только буквы и цифры

Здесь можно использовать isalnum():

'123abc...'.isalnum()
#=> False

'123abc'.isalnum()
#=> True

49. Получите список ключей из словаря

Это можно сделать через передачу словаря в конструктор list():

d = {'id':7, 'name':'Shiba', 'color':'brown', 'speed':'very slow'}

list(d)
#=> ['id', 'name', 'color', 'speed']

50. Как перевести строку в верхний/нижний регистр?

Можно использовать строковые методы upper() и lower():

small_word = 'potatocake'
big_word = 'FISHCAKE'

small_word.upper()
#=> 'POTATOCAKE'

big_word.lower()
#=> 'fishcake'

51. В чем разница между remove, del и pop?

remove() удаляет первое совпадающее значение:

li = ['a','b','c','d']

li.remove('b')
li
#=> ['a', 'c', 'd']

del удаляет элемент по его индексу:

li = ['a','b','c','d']

del li[0]
li
#=> ['b', 'c', 'd']

pop() удаляет элемент по индексу и возвращает этот элемент:

li = ['a','b','c','d']

li.pop(2)
#=> 'c'

li
#=> ['a', 'b', 'd']

52. Приведите пример генератора словарей (dict comprehension)

Ниже мы создадим словарь с буквами алфавита в качестве ключей и индексами в качестве значений:

# создаем список букв
import string
list(string.ascii_lowercase)
alphabet = list(string.ascii_lowercase)

# генерация словаря
d = {val:idx for idx,val in enumerate(alphabet)}

d
#=> {'a': 0,
#=> 'b': 1,
#=> 'c': 2,
#=> ...
#=> 'x': 23,
#=> 'y': 24,
#=> 'z': 25}

53. Как выполняется обработка исключений в Python?

Для обработки исключений Python предоставляет конструкцию из трех слов: try, except и finally.

Синтаксис выглядит примерно так:

try:
    # попробовать сделать это
except:
    # если блок try не сработал, попробовать это
finally:
    # всегда делать это

Ниже упрощенный пример такой конструкции. Здесь блок try терпит неудачу, поскольку мы не можем складывать целые числа со строками. Блок except устанавливает val = 10, а затем блок finally выводит complete:

try:
    val = 1 + 'A'
except:
    val = 10
finally:
    print('complete')
 
print(val)
#=> complete
#=> 10

Конечно, невозможно на 100% угадать, какие вопросы зададут на собеседовании. Лучший способ подготовиться — программировать и еще раз программировать, накапливая опыт.

Однако приведенный список точно поможет тем, кто готовится к собеседованию на позицию дата-сайентиста или junior/middle-разработчика Python.

























Когда вы подаете заявку на должность специалиста по обработке данных, многие компании просят пройти собеседование на работу на знание этого языка. Я попытаюсь изложить вопросы, которые собрал из многих источников и собственного опыта. Постараюсь выбрать наиболее популярные.

1. Что такое Python?
Python — это язык программирования с объектами, модулями, потоками, исключениями и автоматическим управлением памятью. Python предназначен для высокой читабельности. Он часто использует английские ключевые слова, в то время как другие языки используют пунктуацию, и у него меньше синтаксических конструкций, чем у других языков.

2. Каковы преимущества использования Python?
Они заключаются в том, что он прост, удобен, портативен, расширяем, имеет встроенную структуру данных и открытый исходный код.

3. Как Python интерпретируется как язык?
Интерпретируемый язык — это любой язык программирования, который не находится в машинном коде до выполнения. Таким образом, Python им и является.

4. Как интерпретируется Python?
Программа Python запускается непосредственно из исходного кода, написанным программистом. Язык преобразует его в промежуточный код, который снова переводится на машинный язык, который затем уже должен быть выполнен.

5. Как в Python управляется память?
Память в Python управляется приватным пространством кучи Python. В ней расположены все объекты и структуры данных Python. Об этой куче заботится сам интерпретатор Python, а программист не имеет к ней доступа.
Менеджер памяти Python заботится о выделении частного пространства кучи.
Память для пространства кучи Python предоставляется встроенным сборщиком мусора, который перерабатывает и освобождает всю неиспользуемую память.
6. Что такое PEP 8?
PEP расшифровывается как Python Enhancement Proposal (Предложение по улучшению Python). Это набор правил, которые определяют, как форматировать код для максимальной читабельности.

7. Как писать комментарии на Python?
Комментарии начинаются с символа #.

#Пример комментария

8. Как прокомментировать несколько строк в Python?
Многострочные комментарии появляются на нескольких строках. Все строки, подлежащие комментарию, должны иметь префикс #. Можно использовать метод быстрого доступа, чтобы прокомментировать несколько строк. Все, что нужно сделать, — это удерживать клавишу ctrl и щелкнуть левой кнопкой мыши в том месте, где вы хотите включить символ #, и ввести # только один раз. Это закомментирует все строки, на которых щелкнули курсором.

9. Что такое строки документации в Python?
Docstrings не являются комментариями, это строки документации. Они заключены в тройные кавычки. Такие строки не привязаны ни к одной переменной, и поэтому иногда служат в качестве комментариев.

""" 
Это строка документации
Она используется для документирования
"""
10. Обязательны ли отступы в Python?
Отступ в Python является обязательным и является частью его синтаксиса.

Все языки программирования имеют некоторый способ определения объема и масштаба блока кодов — в Python это отступ. Отступ обеспечивает лучшую читабельность кода, и именно поэтому он обязателен.

11. Что такое функция в Python?
Функция — это блок кода, который выполняется только при его вызове. Для определения функции Python используется ключевое слово def. Если функция возвращает что-то, ей нужно ключевое слово return.

def example(a):
   return a*2
12. Что такое локальные и глобальные переменные в Python?
Глобальная переменная:

Переменные, объявленные вне функции или в глобальном пространстве, называются глобальными. Они могут быть доступны любой функции в программе.

Локальная переменная:

Любая переменная, объявленная внутри функции, называется локальной. Она присутствует в локальном пространстве, а не в глобальном.

#Пример глобальной переменной
a = 1

#Пример локальной переменной
def sample():
   #Локальная переменная
   a = 1
13. Что такое лямбда-функция?
Анонимная или неназванная функция называется лямбда-функцией. Она может иметь любое количество параметров, но только один оператор. Она часто используется как одноразовая функция, а не многоразовая.

#Пример лямбда-функции

test = lambda x,y: x*y
print(test(2,4))
14. Почему лямбда-формы в Python не имеют операторов?
Потому что они используются для создания нового объекта функции, а затем возвращают его во время выполнения.

15. Какие типы данных поддерживаются в Python?
Python имеет пять стандартных типов данных −

• число (целочисленные и с плавающей запятой);

• строка;

• список;

• кортеж;

• словарь.

16. Что такое индексы?
Чтобы получить доступ к элементу из упорядоченных последовательностей, мы используем его индекс, который является номером позиции этого конкретного элемента. Индекс обычно начинается с 0, то есть первый элемент имеет индекс 0, второй — 1 и так далее.

#Пример использования индекса

list_ex = [1,2, 'Test']
print(list_ex[0])
17. Что такое отрицательные индексы и почему они используются?
Когда мы используем индекс для доступа к элементам из конца списка, это называется обратным индексированием. При нем индексация элементов начинается с последнего элемента с индексом -1. Второй последний элемент имеет индекс “-2” и так далее. Они называются отрицательными.

#Пример использования индекса

list_ex = [1,2, 'Test']
print(list_ex[-1])
18. Что такое словарь в Python?
Словарь Python — это один из поддерживаемых типов данных. Это неупорядоченная коллекция элементов. Элементы в словарях хранятся в виде пар ключ-значение. Словари индексируются по ключам. Тип данных представлен в виде {}.

#Пример словаря

dictionary = {'key' : 'value'}
19. Как получить доступ к значениям в словаре?
Вы можете получить доступ к значениям в словаре, индексируя их с помощью ключа. Индексация представлена в виде [].

#Доступ к словарю

dictionary = {'key' : 'value'}
print(dictionary['key'])
20. Как получить список всех ключей в словаре?
Можно использовать атрибут, который есть у словаря — keys().

dictionary = {'key' : 'value', 'key1': : 'value1'}
print(dictionary.keys())
21. В чем разница между списком и кортежем?
Разница между списком и кортежем заключается в том, что список является изменяемым, а кортеж — нет. Кортеж может быть хэширован, например, в качестве ключа для словарей. Список определяется с помощью [], а кортеж — с помощью () .

#Пример списка и кортежа

#Список
list_ex = [1,2,'test']

#Список изменяем
list_ex[0] = 100

#Кортеж
tuple_ex = (1,2,'test)

#Кортеж неизменяем
tuple_ex[0] = 100 #Вернет ошибку
22. Что такое итераторы в Python?
В Python итераторы используются для итерации группы элементов, контейнеров, таких как список или строка. Под итерацией подразумевается, что что-то может быть зациклено с помощью оператора.

23. Что делает [:: -1}?
[:: -1] используется для обратного порядка любого итерируемого объекта.

#Пример печати с конца

string = 'this is a string'
print(string[::-1])
24. Как можно использовать тернарные операторы в Python?
Тернарный оператор — это оператор, который используется для отображения условных операторов. Он состоит из истинных или ложных значений с утверждением, которое нужно проверить.

#Пример тернарного оператора

a = 1

#Значения true
if a < 1:
   print('Less')
#Если не выполнилось предыдущее значение
else:
   print('More')
25. Как работает break?
Оператор break позволяет завершить цикл, когда выполняется некоторое условие, и управление передается следующему оператору.

#Пример break

for i in range(5):
   if i < 3:
      print(i)
   else:
      break
26. Каков смысл оператора pass в Python?
Оператор pass в Python используется, когда выражение требуется синтаксически, но вы не хотите, чтобы какая-либо команда или код выполнялись.

#Пример pass

for i in range(10):
   if i%2 == 0:
      print(i)
   else:
      pass
27. Что такое функция map в Python?
map() — это функция, которая принимает другую в качестве аргумента, а затем применяет её ко всем элементам итератора, передаваемым ей в качестве другого аргумента. Функция вернет объект map, поэтому нам нужно преобразовать его в объект списка.

#Пример функции map

def number_exponential(num):
   return num**2

number_list = [2,3,4,5]

print(list(map(number_exponential, number_list)))
28. Что такое функция enumerate в Python?
Метод enumerate() добавляет счетчик к итерируемому и возвращает его в виде объекта перечисления (enumerate). Объект будет состоять из счетчика и итерационных значений.

#Пример enumerate

iter_example = ['test', 'test2', 'test3']
for idx, val in enumerate(iter_example):
   print(idx)
   print(val)
29. Что такое абстракции у словаря и списка в Python?
Они представляют собой синтаксические конструкции, облегчающие создание словаря или списка на основе существующих итеруемых. Создание происходит циклом внутри самого объекта.

#Абстракция словаря

dict_comprehension = {key:val for key, val in emumerate('sample')}
print(dict_comprehension)

#Абстракция списка

list_comprehension = [i for i in range(5)]
print(list_comprehension)
30. Что такое slicing в Python?
Slicing (отсечение) — это механизм выбора диапазона элементов из таких типов последовательностей, как список, кортеж, строки и т.д. Такое отсечение выполняется методом индексации.

#Пример отсечения

list_example = [1,2,3,4,'test','test2']
print(list_example[1:4])
31. Каков смысл not в операторе?
Операторы — это специальные функции. Они принимают одно или несколько значений и дают соответствующий результат. not вернет обратное логическое значение.

print(not 1 == 2)
32. Каков смысл // в python?
Это оператор целочисленного деления, который используется для деления двух операндов с результатом, показывающим только цифры перед десятичной точкой.

print(5//2)
33. Как добавить новое значение в объект списка?
Это можно сделать с помощью атрибута append(), который есть у списка. При передачи какого-то значения в этот атрибут, оно будет помещено в конец последовательности.

list_example = [1,2,3,4,5]
list_example.append(6)
print(list_example)
34. Что такое поверхностная копия?
Поверхностная копия используется при создании нового типа экземпляра и сохраняет значения, скопированные в новом. Также она используется для копирования ссылочных указателей. Это означает, что когда мы копируем объект в другую переменную, он будет привязан.

#Пример поверхностной копии

list_example = [1,2,3,4,5]
another_list = list_example
another_list[0] = 100
print(list_example)
35. Что такое глубокая копия?
Глубокая копия используется для хранения значений, которые уже скопированы. Глубокая копия не копирует ссылочные указатели на объекты. Она создает ссылку на объект, и новый объект, на который указывает другой, сохраняется. В отличие от неглубокой копии, изменения, внесенные в исходную копию, не повлияют ни на одну другую копию, использующую объект. Это значит, что они не привязаны.

#Пример глубокой копии

list_example = [1,2,3,4,5]

#Создание глубокой копии с помощью атрибута .copy
another_list = list_example.copy()
another_list[0] = 100
print(list_example)
36. Как создать пустой класс в Python?
Пустой класс — это класс, который не имеет никакого кода, определенного в его блоке. Он может быть создан с помощью ключевого слова pass. Однако объекты этого класса можно создать и вне самого класса. В Python команда pass ничего не делает при ее выполнении, это null.

class sample:
    pass
test=sample()
test.name="test1"
print(test.name)
37. Что означает ключевое слово self в Python?
Ключевое слово self используется в качестве первого параметра функции внутри класса, представляющего экземпляр класса. Объект или экземпляр класса автоматически передается методу, которому он принадлежит, и принимается в ключевом слове “self”. Пользователи могут использовать другое имя для первого параметра функции, которая указывает на объект класса, но рекомендуется использовать ключевое слово “self”, так как оно ближе к соглашению Python.

38. Будет ли цикл do-while работать, если вы не закончите его точкой с запятой?
Это вопрос с подвохом! Во-первых, Python не поддерживает встроенный цикл do-while. Во-вторых, завершение циклов do-while является необходимостью для таких языков, как C++.

39. Как преобразовать список в строку?
В этом случае мы могли бы использовать атрибут .join() из строкового объекта. Здесь мы передали объект списка в атрибут:

list_example = ['apple', 'grape', 'orange']
print(' '.join(list_example))
40. Что такое оператор членства?
Это оператор, который может подтвердить, является ли значение членом в другом объекте. Операторы членства бывают “in” и “not in”.

#Пример операторов членства

print('me' in 'membership')
print('mes' not in 'membership')
41. Что такое операторы тождественности в Python?
Они показывают нам, тождественны ли два значения. Операторы — “is” и “is not”.

#Пример операторов тождественности
print(1 is '1')
print(2 is not '2')
42. Как обрабатывать входные данные в Python?
Для получения входных данных от пользователя можно использовать функцию input(). Она будет принимать входные данные от пользователя и возвращать их в строковый объект.

test = input('input a number: ')
print(test)
43. Что делает функция zip()?
Она вернет итератор кортежей, сформирует n-пару значений из перечисляемых, передаваемых функции. n — это число итерируемых, которые передают функции.

#Пример функции Zip

print(list(zip([1,2,3], ['apple', 'grape', 'orange'], ['x', 2, True])))

for num, fruit, thing in zip([1,2,3], ['apple', 'grape', 'orange'], ['x', 2, True]):
    print(num)
    print(fruit)
    print(thing)
44. В чем разница между тем, когда функция range() принимает один аргумент, два и три?
Когда мы передаем только один аргумент, функция принимает его в качестве стоп-значения. Здесь начальное значение равно 0, а шаговое +1. Итерация с диапазоном всегда будет останавливаться на единицу перед стоп-значением.

for i in range(5):
   print(i)
Когда мы передаем два аргумента, первый из них является начальным значением, а второй — стоп значением.

for i in range(1,5):
   print(i)
Используя три аргумента, первый аргумент является начальным, второй — стоп, а третий — значением шага.

for i in range(1,10,2):
   print(i)
45. Напишите лучший код для перестановки двух чисел местами.
Вы можете выполнить перестановку с помощью одной строки.

a = 1
b = 2

#Перестановка чисел
a, b = b, a
46. Как можно объявить несколько назначений в одной строке кода?
Есть два способа это сделать. Первый — это отдельное объявление переменной в той же строке:

a, b, c = 1,2,3
Другой способ — объявить переменную в той же строке только с одним значением:

a=b=c=1
47. Как вырваться из бесконечного цикла?
Чтобы прервать процесс, нужно нажать Ctrl+C.

48. Что делает оператор with в Python?
Оператор with в Python гарантирует, что код очистки выполняется при работе с неуправляемыми ресурсами путем инкапсуляции общих задач подготовки и очистки. Он может быть использован, чтобы открыть файл, сделать что-то, а затем автоматически закрыть его. Также он может пригодиться для открытия соединения с базой данных, выполнения некоторой обработки, а затем автоматического закрытия, чтобы гарантировать, что ресурсы закрыты и доступны для других. with выполнит очистку ресурсов, даже если выдается исключение.

#Пример оператора with

with open('database.txt') as data:
    print(data)
49. Когда выполняется except, в блоке try-except?
Блок try-except обычно используется, когда мы хотим что-то выполнить, если возникли ошибки. except выполняется, когда код в блоке try вызвал ошибки.

a = (1,2,3)
try:
   a[0] = 2
except:
   print('There is an error')
50. Где вы будете использовать while вместо for?
Для простого повторяющегося цикла, либо тогда, когда не нужно перебирать список элементов, например записи базы данных и символы в строке.

51. Что такое модули Python?
Это независимые скрипты Python с расширением .py, которые можно повторно использовать в других кодах Python или скриптах с помощью оператора import. Модули могут состоять из функций, классов и переменных, а также некоторого выполняемого кода. Они помогают не только упорядочить коды Python, но и сделать их менее сложными и более эффективными.

import #имя модуля
52. Что такое PYTHONPATH?
PYTHONPATH — это переменная окружения, которая при импорте проверяется на наличие импортированных модулей в различных каталогах. Интерпретатор использует её, чтобы определить, какой модуль следует загрузить.

53. Назовите пример режимов обработки файлов с помощью Python?
Существуют следующие режимы:

Режим только для чтения (‘r’): открыть файл для чтения. Это режим по умолчанию.
Режим только для записи (‘w’): открыть файл для записи. Если файл содержит данные, они будут потеряны. Создается новый файл.
Режим чтения-записи (‘rw’): открыть файл для чтения, режим записи. Это режим обновления.
Режим добавления (‘a’): открыть для записи, добавить в конец файла, если файл существует.
54. Что такое pickling и unpickling?
Модуль pickle принимает любой объект Python, преобразует его в строковое представление и сохраняет в файл с помощью функции dump, такой процесс называется pickling. Процесс извлечения исходных объектов Python из сохраненного строкового представления называется unpickling.

import pickle

a = 1

#Процесс pickling
pickle.dump(a, open('file.sav', 'wb'))

#Процесс unpickling
file = pickle.load(open('file.sav', 'rb'))
55. Являются ли массивы Python NumPy лучше списков?
Мы используем массивы Python NumPy вместо списка по следующим трем причинам:

1. меньший объем памяти;

2. быстрее;

3. удобнее.

56. Как вычислять процентили с помощью NumPy?
Медиана — это 50 процентиль по определению. 25 процентиль указывает, что 25% наблюдаемых меньше числа в процентиле, то есть n процентов наблюдаемых значений меньше значения в процентиле n.

Мы можем вычислить его с помощью NumPy, используя следующий код:

import numpy as np

a = np.array([i for i in range(100)])
p = np.percentile(a, 50) #Возвращает 50-ый перцентиль - медиану

print(p)
57. Как получить текущий рабочий каталог с помощью Python?
Работая с Python, вам может понадобиться читать и записывать файлы из различных каталогов. Чтобы узнать, в каком вы сейчас работаете, можно использовать метод getcwd() из модуля os:

import os
os.getcwd()
58. Что вы видите снизу? Что произойдет, если мы выполним этот код?
a = '1'
b = '2'
c = '3's = a + ‘[‘ + b + ‘:’ + c + ‘]’
print(s)
Это конкатенация строк. Если даже одна из переменных не является строкой, она вызовет ошибку типа (TypeError). Выполнив этот код, мы получим результат конкатенации.

59. Как бы вы произвели рандомизацию содержимого списка на месте?
Мы можем воспользоваться функцией shuffle() из модуля random:

from random import shuffle
list_example = [1,2,3,4,5,6,7,8]
shuffle(list_example)
60. Что такое приведение в Python?
Приведение — это процесс преобразования значения переменной из одного типа в другой. В Python это можно сделать с помощью таких функций, как list(), int (), float() и str(). Примером может служить преобразование строки в целочисленный объект:

a = '1'
b = int(a)
61. Объясните ошибку
from numpy imprt stdev

ImportError Traceback (most recent call last)
<ipython-input-26-685c12521ed4> in <module>
----> 1 from numpy import stdev

ImportError: cannot import name 'stdev' from 'numpy'
В приведенном выше коде мы пытаемся импортировать несуществующую функцию из модуля numpy. В этом причина.

62. Как можно удалить переменные в Python?
Для удаления переменной мы можем использовать функцию del(). Считается хорошей практикой, убрать что-то лишнее, что не используется.

a = 1
del a
63. Что такое pandas в Python?
Pandas — это пакет Python, предоставляющий быстрые, гибкие и функциональныеструктуры данных, предназначенные для того, чтобы сделать работу с “реляционными” или “помеченными” данными простой и интуитивно понятной. Он призван стать фундаментальным строительным блоком высокого уровня для практического анализа реальных данных в Python.

64. В чем разница между методами append() и extend()?
Они используются для добавления элементов в конец списка.

append(элемент): добавляет элемент в конец списка;
extend(другой список): добавляет элементы другого списка в конец первого.
65. Как получить текущую версию Python?
Мы можем узнать текущую версию Python с помощью sys.version:

import sys
sys.version
66. Что значит *args, **kwargs? И зачем нам их использовать?
Мы используем *args, когда неуверены, сколько аргументов будет передано функции, или если хотим передать сохраненный список или кортеж аргументов функции. **kwargs используется, когда мы не знаем, сколько аргументов ключевых слов будет передано, а также он может быть использован для передачи значений словаря в качестве аргументов ключевых слов. Идентификаторы args и kwargs необязательны, вы можете изменить их на другие, типа *другой **пример, но лучше использовать имя по умолчанию.

#Пример *args
def sample(*args):
    print(args)

sample('time', 1, True)

#Пример **kwargs
def sample(**kwargs):
    print(kwargs)

sample(a = 'time', b = 1)
67. Что за функции help() и dir() в Python?
Функция help() отображает строку документации и справку для своего аргумента.

import numpy
help(numpy.array)
Функция dir() отображает все элементы объекта (любого вида).

import numpy
dir(numpy.array)
68. Что означает одинарное и двойное подчеркивание перед именем объекта?
Одиночное подчеркивание — имена в классе с подчеркиванием перед ними просто указывают другим программистам, что атрибут или метод предназначен для закрытого использования, однако с самим именем ничего особенного не делается.

Двойное подчеркивание (искажение имени) — любой идентификатор вида __spam (не менее двух ведущих подчеркиваний, не более одного завершающего) заменяется на _имякласса__spam, где имя класса — это текущее спрятанное имя с подчеркиванием перед ним. Это искажение выполняется без учета синтаксической позиции идентификатора, поэтому его можно использовать для определения экземпляра закрытого класса и его переменных, методов, а также глобальных и других переменных, хранящихся в экземплярах, частных для этого класса в экземплярах других.

69. Каков результат нижеприведенного запроса?
ss = “Python Programming!”
print(ss[5])

Ответ: ‘n’
70. Напишите программу на Python, чтобы создать треугольник из звезд
def star_triangle(r):
   for x in range(r):
      print(' '*(r-x-1)+'*'*(2*x+1))

star_triangle(7)

71. Что плохого в следующем коде:
counter = 0

def increment():
   counter += 1

increment()
В Python нет объявлений переменных, поэтому он должен сам определить их область действия. Если внутри функции имеется обращение к переменной, то она считается локальной. Переменная counter выше является глобальной, поэтому код выбрасывает ошибку.

72. Как разделить строку на список?
Мы можем использовать атрибут split(). Он принимает разделитель в качестве аргумента и возвращает список, состоящий из результатов разделения строки на его основе.

text = 'hello again world !'
text.split(' ')
73. Напишите программу на Python, чтобы проверить, является ли последовательность, которую вы вводите, палиндромом
a=input("enter the sequence: ")
b=a[::-1]

if a==b:
   print("palindrome")
else:
   print("Not a Palindrome")
74. Что такое генератор?
Генератор Python создает последовательность значений для итерации, часто с помощью функции. Мы определяем функцию с помощью yield , которая используется для получения значения по одному, а затем используем цикл for для итерации.

def squares(n):
    i=1
    while(i<=n):
        yield i**2
        i+=1
for i in squares(7):
    print(i)
75. Напишите программу на Python для проверки, является ли число простым
a=int(input("enter a number"))     
if a>1:
    for x in range(2,a):
        if(a%x)==0:
            print("not prime")
            break
    else:
        print("Prime")
else:
    print("not prime")
76. Какова цель одинарной переменной подчеркивания ( ‘ _ ’ ) в Python?
Она предназначена для хранения результата последнего выполненного выражения (/statement) в сеансе интерактивного интерпретатора. Этот прецедент был установлен стандартным интерпретатором CPython, а другие последовали этому примеру.

77. Каковы типы наследования в Python?
Python поддерживает различные типы наследования. Ими являются:

единичное наследование;
многоуровневое наследование;
иерархическое наследование;
множественное наследование.
78. Что такое распаковка кортежа?
Это процесс распаковки его значений и их ввода в несколько различных переменных.

tup = (1,2,3)

#Процесс распаковки кортежа
a,b,c = tup
79. Освобождается ли вся память при выходе из Python?
Выход из Python освобождает все, кроме:

1. модулей с циклическими ссылками;

2. объектов, на которые ссылаются глобальные пространства имен;

3. части памяти, зарезервированной библиотекой C.

80. Является ли функция допустимой, если она не имеет оператора return?
Функция, которая ничего не возвращает, возвращает объект None. Ключевое слово return необязательно обозначает конец функции, оно просто завершает ее, если присутствует. Обычно блок кода помечает функцию, и там, где заканчивается блок, заканчивается и тело функции.




























Общие вопросы по Python с ответами
В1. Основные фичи питона?

Если питон оказался первым языком в опыте программирования, нужно иметь общее понимание о нем. Какие у него основные признаки:
- это интерпретируемый язык
- в нем динамическая типизация данных
- это объектно-ориентированный язык
- он лаконичный и внешне простой
- распространяется бесплатно
- у него большое сообщество

В2. В чем разница между списками (list) и кортежами (tuple)?

Основная разница в том, что список может изменяться (mutable), а кортеж не может (immutable).

>>> mylist = [1, 3, 3]
>>> mylist[1] = 2
>>> mytuple = (1, 3, 3)
>>> mytuple[1] = 2
Traceback (most recent call last):
File “<pyshell#97>”, line 1, in
mytuple[1] = 2
TypeError: "tuple" object does not support item assignment

В3. Как в питоне работает трёхместный (тернарный) оператор?

В питоне есть такие выражения:
[если верно] if [выражение] else [если неверно]

То есть, когда выражение верное (True), то исполняется код [если верно]. В остальных случаях исполняется код [если неверно]. Например:

>>> a, b = 2, 3
>>> min = a if a < b else b
>>> min
2

>>> print("Hi") if a < b else print("Bye")
Hi

В4. Что такое отрицательный индекс (negative index)?

Возьмем для примера список:

>>> mylist = [0, 1, 2, 3, 4, 5 ,6, 7, 8]
В отличие от положительного индекса отрицательный начинает поиск с конца:

>>> mylist[-3]
6
Еще это помогает при создании срезов с конца:

>>> mylist[-6:-1]
[3, 4, 5, 6, 7]
В5. Питон чувствителен к регистру?

Язык считается чувствительным к регистру в случае, если он различает имена "myname" и "Myname". То есть, если он отслеживает разницу регистра (между верхним и нижним). Посмотрим, как с этим в питоне.

>>> myname="Ayushi"
>>> Myname
Traceback (most recent call last):
File “<pyshell#3>”, line 1, in
Myname
NameError: name "Myname" is not defined

Убедились в том, что питон чувствителен к регистру.

В6. Предельно допустимая длина идентификатора в питоне?

В питоне идентификатор может быть любой длины. Помимо этого есть несколько правил для присвоения имен:
- первым символом может быть нижнее подчеркивание (_), символы A-Z или a-z;
- остальная часть имени может состоять из символов A-Z/a-z/_/0-9;
- не забываем, что питон чувствителен к регистру;
- в качестве имени нельзя использовать ключевые слова (keywords):
and, def, False, import, not, True, as, del, finally, in, or, try, assert, elif, for, is, pass, while, break, else, from, lambda, print, with, class, except, global, None, raise, yield, continue, exec, if, nonlocal, return.

В7. Как можно преобразовать строку (string) в нижний регистр (lowercase)?

Для этого используется метод lower():

>>> "AyuShi".lower()
"ayushi"
Для преобразования в верхний регистр (uppercase) используется метод upper():

>>> "AyuShi".upper()
"AYUSHI"
Еще есть методы isupper() (все символы в верхнем регистре) и islower() (все символы в нижнем регистре), которые проверяют регистр всех символов имени.

>>> "AyuShi".isupper()
False

>>> "AYUSHI".isupper()
True

>>> "ayushi".islower()
True

>>> "@yu$hi".islower()
True

>>> "@YU$HI".isupper()
True

Как видим, символы наподобие @ и $ применимы в обоих случаях.

Еще есть метод istitle(), который проверяет строку на стиль заголовка (все слова должны начинаться с символа в верхнем регистре):

>>> "The Corpse Bride".istitle()
True
В8. Для чего нужен pass (pass statement) в питоне?

Иногда нужно, чтобы код не давал никакого результата и не показывал ошибку, например, если еще не готово, но нужно иметь синтаксический корректный код. Можно поставить pass:

>>> def func(*args):
pass
Кроме него есть break (break statement), которое разрывает цикл:

>>> for i in range(7):
if i == 3: break
print(i)
0
1
2
Наконец, есть continue (continue statement), которое перешагивает на следующую итерацию:

>>>for i in range(7):
if i==3: continue
print(i)
0
1
2
4
5
6

Часто задаваемые вопросы на собеседовании по Python с ответами (без опыта работы)
В9. Расскажите про функции help() и dir() в питоне.

Функция help() показывает строку документации и справку для ее аргумента:

>>> import copy
>>> help(copy.copy)
Help on function copy in module copy: # справка по функции copy в модуле copy:
copy(x)
Shallow copy operation on arbitrary Python objects. # операция поверхностного копирования для выбранного объекта питона.
See the module"s __doc__ string for more info. № # дополнительную информацию см. в строке __doc__ этого модуля.
Функция dir() возвращает список, содержащий пространство имен в объекте:

>>> dir(copy.copy)
["__annotations__", "__call__", "__class__", "__closure__", "__code__", "__defaults__", "__delattr__", "__dict__", "__dir__", "__doc__", "__eq__", "__format__", "__ge__", "__get__", "__getattribute__", "__globals__", "__gt__", "__hash__", "__init__", "__init_subclass__", "__kwdefaults__", "__le__", "__lt__", "__module__", "__name__", "__ne__", "__new__", "__qualname__", "__reduce__", "__reduce_ex__", "__repr__", "__setattr__", "__sizeof__", "__str__", "__subclasshook__"]
В10. Как получить список из всех ключей словаря (dictionary keys)?

На такие вопросы нужно отвечать детально, с примерами. Данная задача выполняется с помощью функции keys():

>>> mydict={"a":1,"b":2,"c":3,"e":5}
>>> mydict.keys()
dict_keys(["a", "b", "c", "e"])
В11. Что такое срез?

Срез — это методика, которая позволяет получить часть списка, кортежа или строки.

>>> (1, 2, 3, 4, 5)[2:4]
(3, 4)

>>> [7, 6, 8, 5, 9][2:]
[8, 5, 9]

>>> "Hello"[:-1]
"Hell"

В12. Как пишутся комментарии в питоне?

Для этого используется символ #. Все, что написано на строке после него, считается комментарием и игнорируется. Комментарии используются для объяснения цели написанного кода. Многострочных комментариев в прямом смысле слова в питоне нет.

>>> # первая строка комментария
>>> # вторая строка комментария

В13. Как проверить, что все символы строки относятся к алфавитно-цифровым?

Для этого используется метод isalnum().

В14. Как перевести первый символ строки в верхний регистр?

Для этого есть метод capitalize():

>>> "ayushi".capitalize()
"Ayushi"
В15. Все знают, что сегодня питон в моде. Но истинное принятие новой технологии подразумевает понимание ее недостатков. Что вы можете сказать по этому поводу?

Какие в питоне есть ограничения:
- интерпретируемая природа питона снижает скорость исполнения программы
- его не выгодно использовать для мобильных устройств и браузеров
- будучи языком с динамической типизацией данных, он использует утиную типизацию; в связи с этим появляются ошибки исполнения (runtime errors);
- в нем слабо развиты возможности доступа к базам данных; поэтому питон не идеальный вариант для приложений с очень большими базами данных;
- низкие требования на входе, то есть свои силы в питоне может попробовать каждый; это иногда снижает качество кода;
- у питона индивидуально выраженный стиль.

В16. Как в питоне узнать, в какой мы сейчас директории?

Для этого используется функция getcwd(). Она импортируется из модуля os:

>>> import os
>>> os.getcwd()
"C:\\Users\\lifei\\AppData\\Local\\Programs\\Python\\Python36-32"
В17. Как вставить объект, чтобы он оказался под определенным индексом?

Сначала создадим список:

>>> a=[1, 2, 4]
Затем используем метод insert(). В нем первым аргументом будет индекс, под которым вставляется объект, а вторым — значение объекта:

>>> a.insert(2,3)
>>> a
[1, 2, 3, 4]
В18. Как можно обратить (reverse) порядок элементов в списке?

Для этого есть метод reverse():

>>> a.reverse()
>>> a
[4, 3, 2, 1]
В19. Что такое приглашение интерпретатора (interpreter prompt)?

Когда мы заходим в интерпретатор питона, то видим следующую строку:

>>>
В20. Что нужно сделать, чтобы функция возвратила значение?

Для этого используется ключевое слово return:

>>> def add(a, b):
return a + b
В21. Что такое блок?

Когда мы пишем предложение (statement), нам нужно завершить первую строку двоеточием, а под ним написать блок кода, который исполняется в рамках этого предложения. Каждая строка блока пишется с одинаковым отступом.

>>> if 3 > 1:
print("Hello")
print("Goodbye")
Hello
Goodbye

В22. Зачем нужны break и continue?

Они используются для управления последовательностью операций: break останавливает исполнение цикла и переводит исполнение на следующий блок кода, continue как бы перепрыгивает на следующую итерацию цикла и не прекращает его исполнение.

В23. Если мы не поставим двоеточие в конце строки для цикла "do-while", он все равно сработает?

В питоне такой цикл не реализован. Это вопрос из тех, которые с подвохом, когда упоминают элементы других языков.

В24. Напишите в одну строку, как можно получить самую позднюю по значению букву в строке.

Значение буквы определяется по ее коду в ASCII. Для этого подойдет функция max():

>>> max("flyiNg")
"y"
С помощью той же логики можно объяснить следующую строку кода:

>>> max("fly{}iNg")
"}"
В25. В каких областях питон имеет преимущество?

Лучше всего питон использовать в следующих областях:
- веб-приложения
- графические интерфейсы пользователя для настольных ПК
- научные и арифметические приложения
- разработка ПО
- разработка программ обучения
- приложения для бизнеса
- сетевые приложения
- игры, 3D-графика

В26. Можете назвать десять встроенных функций питона?

Функция complex() создает комплексное число:

>>> complex(3.5,4)
(3.5+4j)
Функция eval() исполняет строку:

>>> eval("print(max(22,22.0) — min(2,3))")
20
Функция filter() отфильтровывает элементы, для которых заданное условие верно.

>>> list(filter(lambda x: x%2 == 0,[1, 2, 0, False]))
[2, 0, False]

Функция format() помогает задать формат строки:

>>> print("a = {0} but b = {1}".format(a, b))
a = 2 but b = 3
Функция hash() возвращает хэш-значение объекта:

>>> hash(3.7)
644245917
Функция hex() преобразовывает число в шестнадцатеричное число:

>>> hex(14)
"0xe"
Функция input() читает ввод и возвращает строку:

>>> input("Enter a number")
Enter a number7
"7"
Функция len() возвращает число, показывающее длину строки:

>>> len("Ayushi")
6
Функция locals() возвращает словарь с локальной таблицей имен:

>>> locals()
{"__name__": "__main__", "__doc__": None, "__package__": None, "__loader__": <class "_frozen_importlib.BuiltinImporter">, "__spec__": None, "__annotations__": {}, "__builtins__": <module "builtins" (built-in)>, "a": 2, "b": 3}
Функция open() открывает файл:

>>> file = open("tabs.txt")
В27. Какой выход у следующего кода:

>>> word = "abcdefghij"
>>> word[:3] + word[3:]

Выход: "abcdefghij".

В28. Как конвертировать список в строку?

Для этого подойдет метод join():

>>> nums=["one","two","three","four","five","six","seven"]
>>> s=" ".join(nums)
>>> s
"one two three four five six seven"
В29. Как убрать из списка дубликат элемента?

Для этого можно конвертировать список во множество (set):

>>> list = [1, 2, 1, 3, 4, 2]
>>> set(list)
{1, 2, 3, 4}
В30. Можете объяснить жизненный цикл треда?

Общими словами, цикл выглядит так:
- сначала создается класс, который подменяет метод исполнения класса в треде, и создаем экземпляр (instance) для этого класса;
- вызываем start(), который готовит тред к исполнению;
- переводим тред в состояние исполнения;
- можно вызвать разные методы, например sleep() и join(), которые переводят тред в режим ожидания;
- когда режим ожидания или исполнения прекращается, другие ожидающие треды подготавливаются к исполнению;
- после завершения исполнения тред останавливается.


Вопросы для собеседования / интервью о базовых аспектах программирования на питоне с ответами
В31. Что такое словарь (dictionary)?

Словарь содержит пары типа "ключ: значение":

>>> roots={25: 5, 16: 4, 9: 3, 4: 2, 1: 1}
>>> type(roots)
<class "dict">
>>> roots[9]
3

Словарь относится к изменяемым (mutable) объектам. Его можно создать помощью:
- литерала (символов {})
- функции dict()
- генератора (comprehension)

В32. Расскажите про арифметические операторы //, %, и **.

Оператор // выполняет целочисленное деление и возвращает целую часть числа, полученного в результате операции:

>>> 7 // 2
3
Оператор ** возводит в степень:

>>> 2**10
1024
Оператор % возвращает результат деления по модулю, то есть остаток после деления:

>>> 13%7
6
В33. Что вам известно про операторы сравнения в питоне?

Данные операторы сравнивают значения между собой.

Оператор "меньше" (<): если значение с левой стороны от оператора меньше, он возвращает True:

>>> "hi"<"Hi"
False
Оператор "больше" (>): если значение с левой стороны от оператора больше, он возвращает True:

>>> 1.1+2.2>3.3
True
Оператор "меньше или равно" (<=): если значение с левой стороны от оператора меньше значения с правой стороны или равно ему, он возвращает True:

>>> 3.0 <= 3
True
Оператор "больше или равно" (>=): если значение с левой стороны от оператора больше значения с правой стороны или равно ему, он возвращает True:

>>> True >= False
True
Оператор равенства (==): если значения равны, он возвращает True:

>>> {1,3,2,2} == {1,2,3}
True
Оператор неравенства (!=): если значения не равны, он возвращает True:

>>> False != 0.1
True
В34. Что такое операторы присвоения в питоне?

Все арифметические операторы можно комбинировать с символом присвоения.

>>> a = 7
>>> a += 1
>>> a
8

>>> a -= 1
>>> a
7

>>> a *= 2
>>> a
14

>>> a /= 2
>>> a
7.0

>>> a **= 2
>>> a
49.0

>>> a // =3
>>> a
16.0

>>> a %= 4
>>> a
0.0

В35. Расскажите про логические операторы в питоне.

Всего их три: and, or, not.

>>> False and True
False

>>> 7 < 7 or True
True

>>> not 2 == 2
False

В36. Что такое оператор принадлежности?

Это операторы in и not in. Они показывают, является ли одно значение частью другого.

>>> "me" in "disappointment"
True

>>> "us" not in "disappointment"
True

В37. Расскажите про операторы тождественности.

Операторы is и is not показывают, являются ли два значения идентичными.

>>> 10 is "10"
False

>>> True is not False
True

В38. Что такое битовые операторы?

Данные операторы выполняют операции в битовом формате.

>>> 0b110 & 0b010
2

>>> 3 | 2
3

>>> 3 ^ 2
1

>>> ~2
-3

>>> 1<<2
4

>>> 4>>2
1

В39. Какие типы данных поддерживаются в питоне?

В питоне используется пять типов данных:
- числа, которые содержат числовые значения;
- строки, который представляют собой последовательность символов; обозначаются одинарными или двойными кавычками.
- списки, который представляют собой коллекцию значений; обозначаются квадратными скобками.
- кортежи, которые похожи на списки, но отличаются тем, что не могут быть изменены.
- словари, которые содержат пары "ключ: значение"; обозначаются фигурными скобками.

В40. Что такое строка документации (docstring)?

Она вносится первой строкой в блок, определяющий содержание функции, класса или метода. Содержит описание их цели и способа исполнения. Обозначается тремя одинарными или двойными кавычками с каждой стороны.

>>> def sayhi():
"""
The function prints Hi
"""
print("Hi")

>>> sayhi()
Hi

Посмотреть ее содержание мы можем с помощью __doc__:

>>> sayhi.__doc__
"\n\tThis function prints Hi\n\t"
В отличие от комментария строка документации читается во время исполнения.

В41. Как можно конвертировать строку в число?

Если строка содержит только числовые символы, можно использовать функцию int():

>>> int("227")
227
В42. Как можно принять результат ввода на клавиатуре?

Если пользователь что-то вводит с помощью клавиатуры, можно использовать функцию input(). В качестве аргумента можно задать данной функции текст запроса на ввод. Результат ввода всегда является строкой.

>>> a = input("Enter a number")
Enter a number7

В43. Что такое функция?

Когда мы хотим исполнить определенную последовательность (sequence of statements), мы можем дать ей имя. Например, определим функцию, которая принимает два числа и возвращает то, которое больше.

>>> def greater(a,b):
return a is a>b else b
>>> greater(3,3.5)
3.5

В44. Что такое рекурсия?

Это когда функция вызывает саму себя. При этом она должна иметь базовое условие, чтобы не создать бесконечный цикл:

>>> def facto(n):
if n == 1: return 1
return n * facto(n - 1)
>>> facto(4)
24
В45. Что делает функция zip()?

Возвращает итератор с кортежами:

>>> list(zip(["a", "b", "c"],[1, 2, 3]))
[("a", 1), ("b", 2), ("c", 3)]
В данном случае она совмещает элементы двух списков и создает из них кортежи. Работает не только со списками.

В46. Как посчитать длину строки (string)?

Для этого вызываем функцию len():

>>> len("Ayushi Sharma")
13
В47. Расскажите про генераторы списков (list comprehension).

Они позволяют создавать списки с помощью одной строки кода:

>>> [i for i in range(1, 11, 2)]
[1, 3, 5, 7, 9]
В48. Как можно получить все значения из словаря?

Для этого используется метод values()

>>> 4 in {"a":1,"b":2,"c":3,"d":4}.values()
True
В49. Как можно переключить регистр строки?

Можно использовать метод swapcase(), предусмотренный для класса str:

>>> "AyuShi".swapcase()
"aYUsHI"
В50. Возьмем строку "I love Python". Напишите код, который выведет символы до буквы "t".

>>> s = "I love Python"
>>> i = 0
>>> while s[i] != "t":
print(s[i], end="")
i += 1
>>> I love Py

В51. Возьмем строку "I love Python". Напишите код, который выведет эту строку без пробелов.

>>> s = "I love Python"
>>> for i in s:
if i == ' ': continue
print(i, end='')
>>> IlovePython

В52. Возьмем строку "I love Python". Напишите код, который выведет эту строку пять раз подряд.

>>> s = "I love Python"
>>> for i in range(6):
print(s)
>>> I love Python
>>> I love Python
>>> I love Python
>>> I love Python
>>> I love Python

В53. Для чего используется bytes()?

Это встроенная функция питона, которая возвращает неизменяемый байтовый объект.

>>> bytes([2,4,8])
b’\x02\x04\x08′

>>> bytes(5)
b’\x00\x00\x00\x00\x00′

>>> bytes('world','utf-8')
b’world’

В54. Что такое оператор контроля последовательности (control flow statement)?

Обычно программа в питоне начинает исполнение с первой строки. После нее программа однократно исполняет каждое предложение. Когда будет исполнено последнее предложение, программа прекращается. Также контроль последовательности помогает усложнить обычный порядок исполнения программы.

В55. Создайте новый лист с помощью конвертации списка числовых строк в список чисел.

>>> nums = [‘22’, ’68’, ’110’, ’89’, ’31’, ’12’]

Теперь возьмем функцию int() и создадим генератор списка, который конвертирует строки в числа и внесет их в список:

>>> [int(i) for i in nums]
[22, 68, 110, 89, 31, 12]
В56. Как лучше всего хранить имена и фамилии наших работников?

Можно создать словарь, содержащий пары "ключ: значение":

{"имя": "Ayushi", "фамилия": "Sharma"}

Топ вопросов по Python с ответами
В57. Как работать с числами, которые не входят в десятичную систему счисления?

В питоне можно вводить бинарные, восьмеричные и шестнадцатеричные числа.

Бинарные. Это числа, составленные из 0 и 1. Для ввода в бинарном формате, используется префикс 0b или 0B:

>>> int(0b1010)
10
Число можно преобразовать в бинарный формат с помощью функции bin():

>>> bin(0xf)
‘0b1111’
Восьмеричные числа могут состоять из цифр от 0 до 7, также используется префикс 0o или 0O:

>>> oct(8)
‘0o10’
Шестнадцатеричные числа могут состоять из цифр от 0 до 15, также используется префикс 0x или 0X:

>>> hex(15)
‘0xf’
В58. Какой результат выводит данный код:

>>> def extendList(val, list=[]):
list.append(val)
return list
>>> list1 = extendList(10)
>>> list2 = extendList(123,[])
>>> list3 = extendList('a')
>>> list1, list2, list3
[10, ‘a’], [123], [10, ‘a’]

Возможный, но неверный ответ: ([10], [123], [‘a’])

В функции есть аргумент list=[], который не запускается в нулевом значении при каждом вызове этой функции. Когда мы первый раз определяем функцию, она создает новый список. Затем, каждый раз, когда мы вызываем данную функцию без аргумента-списка, она использует один и тот же список. Питон исполняет выражения, которые имеют нулевые значения, при определении функции, а не при вызове функции.

В59. Сколько аргументов может принять range()?

От одного до трех:

>>> list(range(5))
[0, 1, 2, 3, 4]
>>> list(range(-5))
[]
>>> list(range(2, 7))
[2, 3, 4, 5, 6]
>>> list(range(-3, 4))
[-3, -2, -1, 0, 1, 2, 3]
>>> list(range(2, 9, 2))
[2, 4, 6, 8]
>>> list(range(9, 2, -1))
[9, 8, 7, 6, 5, 4, 3]
В60. Что такое РЕР8?

Это соглашение о программировании в питоне, которое содержит рекомендации для повышения читаемости кода.

В61. Чем Python отличается от Java?

Если сравнивать Python и Java:
- Java быстрее
- Python использует отступы, а Java нужны скобки
- в Python динамическая типизация, а в Java — статическая
- Python — простой и лаконичный, а Java — многословный язык
- Python — интерпретируемый язык
- Java не зависит от используемой платформы
- в Java есть интерфейс JDBC, который улучшает доступ к базам данных

В62. Как лучше всего поменять местами числовые значения объектов?

>>> a, b = b, a

Как выполняется этот код:

>>> a, b = 2, 3
>>> a, b = b, a
>>> a, b
(3, 2)
В63. Как можно выполнить несколько операций присвоения в одном предложении?

Первый способ (несколько объектов с уникальными значениями):

>>> a, b, c = 3, 4, 5
Второй способ (несколько объектов с идентичными значениями):

>>> a = b = c = 3
В64. Как выйти из бесконечного цикла?

Можно нажать комбинацию клавиш Ctrl+C, которая прерывает исполнение.


Технические вопросы для собеседования / интервью по Python с ответами
В65. Как исполняется код в питоне?

Файлы питона сначала компилируются в байткод, который затем исполняется.

В66. Расскажите, какой в питоне механизм передачи параметров.

В питоне используется передача параметров по ссылке. Если изменить параметр внутри функции, то это отразится на выводе функции. Однако, если использовать в качестве параметров литералы (строки, числа, кортежа), то они передаются по значению (потому что они не изменяемые).

В67. Что такое with в питоне?

Данная инструкция обеспечивает исполнение кода очистки после исполнения программы. Например, можно использовать ее для открытия файла, совершить с ним какие-то действия и автоматически закрыть файл после завершения работы. Аналогичным образом можно открывать соединение с базой данных и автоматически его закрывать. Код очистки исполняется даже в случае, когда появляется исключение (exception).

>>> with open('data.txt') as data:
# исполняемый блок

В68. Чем файл .pyc отличается от .py?

Оба файла содержат байткод, но .pyc является компилированной версией файла питона. Его байткод не зависит от платформы, поэтому он исполняется на всех платформах, которые поддерживают формат .pyc.

В69. Что делает питон объектно-ориентированным?

Он следует парадигме объектно-ориентированного программирования, которая построена вокруг классов (classes) и их экземпляров (instances). Это позволяет реализовать следующие функции:
- сокрытие внутренней структуры данных
- абстракция
- наследование
- полиморфизм (способность выбирать правильный метод в зависимости от типа данных)
- ограничение доступа к данным

В70. Какие есть типы объектов в питоне?

В питоне поддерживаются изменяемые (mutable) и не изменяемые (immutable) типы объектов.

Не изменяемые не позволяют изменять свое содержание. Примеры: кортежи, булевы, строки, числа. Итерация по ним выполняется быстрее.

Изменяемые позволяют изменять свое содержание. Примеры: списки, множества и словари. Итерация по ним выполняется медленнее.




















В1. Когда в блоке try-except исполняется элемент else?

В блоке if-else элемент else исполняется в случае, если условие в операторе if (if statement) является неверным (False). А вот в блоке try-except элемент else исполняется только в случае, если элемент try не выдает исключение.

В2. Допустим, есть список nums=[0,1,2,3,4]. Что означает nums[-1]?

Данный код не будет выдавать исключение. nums[-1] — это 4, потому что движение по элементам начинается справа.

В3. Что такое переменная PYTHONPATH?

PYTHONPATH — эта переменная сообщает интерпретатору путь до файлов модуля, импортированных в программу. Поэтому она должна включать в себя директорию с библиотекой-источником питона и директории с исходным кодом питона. Переменную PYTHONPATH можно назначить самостоятельно, однако обычно ее предустанавливает установщик питона.

В4. Расскажите про функции join() и split() в Python.

Функция join() позволяет соединять символы строки (string), чередуя с указанным символом.

>>> ','.join('12345')
‘1,2,3,4,5’
Функция split() позволяет разделить строку, чередуя символы с указанным символом.

>>> '1,2,3,4,5'.split(',')
[‘1’, ‘2’, ‘3’, ‘4’, ‘5’]
В5. Расскажите, какая будет выдача у этого кода:

x=[‘ab’,’cd’]
print(len(map(list,x)))
Здесь будет ошибка определения типа (TypeError). Ее причиной является отсутствие атрибута len() у функции map(). Это можно проверить функцией dir().

В6. Приведите несколько методов, с помощью которых можно реализовать в питоне функционально ориентированное программирование.

Несколько методов могут помочь с итерацией по списку (list).

1. filter() может отфильтровать несколько значений на основе условия.

>>> list(filter(lambda x:x>5,range(8)))
[6, 7]
2. map() применяет функцию к каждому элементу итерируемого объекта.

>>> list(map(lambda x:x**2,range(8)))
[0, 1, 4, 9, 16, 25, 36, 49]
3. reduce() продолжает уменьшать последовательность (sequence) парами, пока не будет достигнуто единичное значение.

>>> from functools import reduce
>>> reduce(lambda x,y:x-y,[1,2,3,4,5])
-13
В7. И все-таки, какая выдача у этого кода:

x=[‘ab’,’cd’]
print(len(list(map(list,x))))
Здесь на выходе ‘2’, потому что длина этого списка составляет два элемента. Выдача у list(map(list,x)) будет [[‘a’, ‘b’], [‘c’, ‘d’]], а в этом списке два элемента.

В8. Можно ли сказать, что del и remove() — это одно и то же? Что это такое, в целом?

del и remove() — это методы для списков, они нужны для удаления элементов.

>>> list=[3,4,5,6,7]
>>> del list[3]
>>> list
[3, 4, 5, 7]
>>> list.remove(5)
>>> list
[3, 4, 7]
del позволяет удалять элементы под конкретным индексом, а remove() позволяет удалять элементы на основе их значения.

В9. Как нужно открывать файл для записи?

Допустим, есть файл tabs.txt. Чтобы открыть его и записывать в него, необходим такой код:

>>> file=open('tabs.txt','w')
Теперь файл открылся в режиме записи. После завершения работы файл нужно закрыть.

>>> file.close()
В10. Объясните, почему у следующего кода такая выдача:

>>> tuple=(123,'John')
>>> tuple*=2
>>> tuple
(123, ‘John’, 123, ‘John’)
В этом коде кортеж (tuple) умножается на 2. Поэтому его содержимое удваивается. То есть, на выходе мы получим (123, ‘John’, 123, ‘John’). Со строками тоже можно так сделать:

>>> 'ba'+'na'*2
‘banana’
В11. Какие различия есть между методами для списков append() и extend()?

Метод append() добавляет элемент к концу списка, а метод extend() добавляет к концу списка переданный ему итерируемый объект (iterable). Возьмем два списка.

>>> list1, list2 = [1, 2, 3], [5, 6, 7, 8]
Вот так действует append():

>>> list1.append(4)
>>> list1
[1, 2, 3, 4]
А вот так действует extend():

>>> list1.extend(list2)
>>> list1
[1, 2, 3, 4, 5, 6, 7, 8]
В12. Какие есть режимы обработки файлов в Python?

Предусмотрены следующие режимы:

только чтение – ‘r’
только запись – ‘w’
чтение-запись – ‘rw’
добавление в конце – ‘a’
Можно открыть текстовый файл с опцией ‘t’. Поэтому, чтобы открыть текстовый файл для чтения, можно использовать режим ‘rt’. Точно так же для бинарных файлов используется ‘b’.

В13. Что делает функция map()?

Функция map() возвращает итератор, который применяет функцию, переданную ей в первом аргументе, ко всем элементам итерируемого объекта (iterable), переданного ей во втором аргументе. Можно показать пример?

>>> for i in map(lambda i:i**3, (2,3,7)):
....print(i)
8
27
343
На выходе – элементы 2, 3, 7, возведенные в куб.

В14. Расскажите про try, raise и finally.

Это ключевые слова (keywords) для обработки исключений (exception handling). Потенциально рискованный код помещается в блок try, оператор raise (raise statement) используется для прямого вызова ошибки, а в блоке finally находится код, который исполняется в любом случае.

В15. Что случится, если не обработать ошибку в блоке except?

Если этого не сделать, программа завершится. Затем она отправит трассу исполнения на sys.stderr.

В16. Есть ли возможность удалить последний объект списка?

Да, такая возможность предусмотрена. Можно попробовать такой вариант:

>>> list=[1,2,3,4,5
>>> list.pop(-1)
5
>>> list
[1, 2, 3, 4]
В17. Как можно преобразовать целое число (integer) в символ Unicode?

Для этого просто нужна встроенная функция chr(x). Можно показать?

>>> chr(52)
‘4’
>>> chr(49)
‘1’
>>> chr(67)
‘C’
В18. Объясните, какая проблема с этим кодом:

>>> def func(n=[]):
#playing around
pass
>>> func([1,2,3])
>>> func()
>>> n
В результате запроса n появляется ошибка присвоения названия (NameError), потому что n является локальной переменной функции func. В другом месте она недоступна. Также Python определяет значения параметров по умолчанию только один раз, поэтому каждый вызов функции использует то же значение по умолчанию. Если во время какого-то вызова будет изменено значение по умолчанию, то в следующем вызове будет использовано новое значение.

В19. Что здесь написано?

s = a + ‘[’ + b + ‘:’ + c + ‘]’
Здесь выполняется сцепление строк (string concatenation). Если a, b и c являются строками (strings), то все пройдет нормально, они будут сцеплены со строками ‘[’, ‘:’ и ‘]’. Однако, если хотя бы один из элементов сцепления не является строкой, то появится ошибка TypeError.

В20. Может ли рекурсия создавать сложности?

Разумеется:

Приходится чаще вызывать функцию.
Каждый вызов функции сохраняет переменную состояния в программном стеке, то есть растет потребление памяти, что в итоге может стать причиной переполнения памяти.
Вызовы функции отнимают время.
В21. Какие преимущества у рекурсии?

Рекурсия помогает:

экономить усилия на выполнение задачи,
сократить объем кода по сравнению с циклами,
легче воспринимать код.
В22. Какой выход у этого кода?

>>> b=(1)
На выходе не будет кортежа (tuple). Мы получим обычное целое число.

>>> type(b)
Чтобы получить кортеж, мы можем добавить прямую декларацию с помощью запятой после числа 1:

>>> b=(1,)
>>> type(b)
В23. Почему игнорируются имена-идентификаторы, которые начинаются с символа подчеркивания?

В питоне не реализована концепция скрытой переменной (private variable), поэтому принято декларировать скрытые переменные первым символом в виде нижнего подчеркивания.

В24. Можно ли удалить пробелы из строки (string) “aaa bbb ccc ddd eee”?

Я вспомнил три способа.

Функция join():

>>> s='aaa bbb ccc ddd eee'
>>> s1=''.join(s.split())
>>> s1
‘aaabbbcccdddeee’
Генератор списка (list comprehension):

>>> s='aaa bbb ccc ddd eee'
>>> s1=str(''.join(([i for i in s if i!=' '])))
>>> s1
‘aaabbbcccdddeee’
Функция replace():

>>> s='aaa bbb ccc ddd eee'
>>> s1 = s.replace(' ','')
>>> s1
‘aaabbbcccdddeee’
В25. Как узнать текущую директорию в питоне?

Чтобы узнать, в какой директории мы сейчас находимся, можно использовать метод getcwd() из модуля os module.

>>> import os
>>> os.getcwd()
‘C:\\Users\\Ayushi\\AppData\\Local\\Programs\\Python\\Python37-32’
В26. Как можно перемешать в случайном порядке (рандомизировать) содержание списка (list) путем его изменения?

Для этого можно импортировать функцию shuffle() из модуля random.

>>> from random import shuffle
>>> shuffle(mylist)
>>> mylist
[3, 4, 8, 0, 5, 7, 6, 2, 1]
В27. Если строка (string) начинается с пробела, как его убрать?

Такой пробел можно убрать с помощью метода lstrip().

>>> ' Ayushi '.lstrip()‘
‘Ayushi '
В этой строке пробелы стояли как в начале, так и в конце. Функция lstrip() убрала крайний слева пробел из строки. Если мы захотим убрать пробел из хвоста, то воспользуемся функцией rstrip().

>>> ' Ayushi '.rstrip()
‘ Ayushi’
В28. Сейчас мы покажем код, в котором нужно удалить числа меньше 5 из списка (list) nums. Однако, ожидаемого эффекта он не дает. Можете показать нам, где баг?

>>> nums=[1,2,5,10,3,100,9,24]
>>> for i in nums:
....if i<5:
........nums.remove(i)
>>> nums
[2, 5, 10, 100, 9, 24]
В данном коде проверяется каждый элемент списка nums, т.е. окажется ли он меньше 5. Если условие выполняется, то данный элемент будет удален. На первой итерации, действительно, оказывается, что 1 меньше 5, поэтому данный элемент удаляется из списка. Однако данное действие вносит путаницу в индексы элементов, поэтому программа проверяет элемент 5, а не элемент 2. Решить данную проблему можно тремя способами:

Можно создать пустой массив и добавлять элементы с конца (append):

>>> nums=[1,2,5,10,3,100,9,24]
>>> newnums=[]
>>> for i in nums:
if i>=5:
newnums.append(i)
>>> newnums
[5, 10, 100, 9, 24]
Можно воспользоваться генератором списка (list comprehension):

>>> nums=[1,2,5,10,3,100,9,24]
>>> newnums=[i for i in nums if i>=5]
>>> newnums
[5, 10, 100, 9, 24]
Можно воспользоваться функцией filter():

>>> nums=[1,2,5,10,3,100,9,24]
>>> newnums=list(filter(lambda x:x>=5, nums))
>>> newnums
[5, 10, 100, 9, 24]
В29. Что за функция enumerate() в Python?

Функция enumerate() осуществляет итерацию вдоль последовательности (sequence), извлекает индекс и его значение.

Посмотрим на примере.

>>> for i,v in enumerate(['Python','C++','Scala']):
....print(i,v)
0 Python
1 C++
2 Scala
В30. Как можно создать такой паттерн в питоне?

*
**
***
****
*****

Можно использовать два цикла for (for-loops).

>>> for i in range(1,6):
....for j in range(1,i+1):
........print('*',end='')
....print()
В31. В каком случае while уместнее, чем for?

В целом, for подойдет во всех случаях, когда применим while, однако есть несколько ситуаций, когда с циклом while проще:

Простые повторяющиеся циклы
Когда не нужно осуществлять итерацию вдоль списка элементов (например, записи в базе данных и символы строки.
В32. Посмотрим на вот такой код:

>>> A0=dict(zip(('a','b','c','d','e'),(1,2,3,4,5)))
>>> A1=range(10)
>>> A2=sorted([i for i in A1 if i in A0])
>>> A3=sorted([A0[s] for s in A0])
>>> A4=[i for i in A1 if i in A3]
>>> A5={i:i*i for i in A1}
>>> A6=[[i,i*i] for i in A1]
>>> A0,A1,A2,A3,A4,A5,A6
Какие будут значения у переменных с A0 по A6? Объясните свой ответ.

Результат будет следующий:

A0={‘a’: 1, ‘b’: 2, ‘c’: 3, ‘d’: 4, ‘e’: 5}
A1=range(0, 10)
A2=[]
A3=[1, 2, 3, 4, 5]
A4=[1, 2, 3, 4, 5]
A5={0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81}
A6=[[0, 0], [1, 1], [2, 4], [3, 9], [4, 16], [5, 25], [6, 36], [7, 49], [8, 64], [9, 81]]
Теперь посмотрим, что тут произошло. A0 сцепляет ‘a’ с 1, ‘b’ с 2 и т.д. с помощью функции zip(). Создаются кортежи (tuples), которые затем передаются функции dict() и преобразовываются в словарь, в котором ключами (keys) и значениями (values) являются элементы кортежей.

A1 создает объект range, который начинается на start=0 и заканчивается на stop=10.

A2 проверяет каждый элемент в A1 на его присутствие в A0. Если ответ утвердительный, элемент добавляется в список (list). Затем этот список упорядочивается (сортируется) с помощью sorted(). Поскольку нет ни одного элемента, присутствующего и в A0, и в A1, на выходе получаем пустой список.

A3 берет каждый ключ в A0 и возвращает его значение. В итоге мы получаем список [1,2,3,4,5].

A4 проверяет каждый элемент A1 на его присутствие в A3. Если ответ утвердительный, элемент добавляется в список, который мы получаем на выходе.

A5 возводит каждый элемент A1 в квадрат и возвращает словарь (dictionary), в котором ключами являются элементы A1 и они же, возведенные в квадрат, являются значениями.

A6 берет каждый элемент A1 и возвращает вложенные списки (sublists) с этими элементами и их квадратами. По одному.

В33. Есть ли в питоне оператор переключения (switch-case statement)?

В питоне такого оператора нет, но можно написать функцию для реализации этого функционала. Как вариант, можно использовать набор операторов if-elif-else. В такой функции может использоваться словарь (dictionary).

>>> def switch(choice):
....switcher={'Ayushi':'Monday', 'Megha':'Tuesday'}
....print(switcher.get(choice,'Hi, user'))
>>> switch('Megha')
Tuesday
>>> switch('Ayushi')
Monday
>>> switch('Ruchi')
Hi, user
В этом примере метод get() возвращает значение (value) для ключа (key). Если нет нужного ключа, возвращается значение, заданное по умолчанию (второй аргумент метода get()).

В34. Объясните разницу между полной копией (deep copy) и поверхностной копией (shallow copy).

Полное копирование создает новый объект-копию. То есть, если внести изменение в копию объекта, то с первоначальным объектом ничего не случится. В Python для этого используется функция deepcopy() с помощью импорта из модуля copy.

>>> import copy
>>> b=copy.deepcopy(a)
Поверхностная копия копирует на новый объект ту ссылку, которая закреплена на первоначальном объекте. Поэтому если внести изменение в копию, то оно распространится на первоначальный объект. Данный функционал реализуется с помощью функции copy().

>>> b=copy.copy(a)
В35. Можно ли создать локальную переменную (local variable), имя которой начинается с символа нижнего подчеркивания?

Можно, но не рекомендуется. Локальными переменными обозначаются скрытые переменные (private variables) класса, поэтому такое действие запутает интерпретатора (interpreter).

В36. Можно ли сказать, что массив (array) NumPy лучше списка (list)?

Массивы NumPy имеют три преимущества перед списками:

Они быстрее
Они потребляют меньше памяти
С ними удобнее работать
В37. Если установить модуль с помощью pip, но импортировать его в интегрированную среду разработки (IDLE) не получается. В чем может быть причина?

Возможно, в системе установлена более чем одна версия питона. Например 32- и 64-битную.
Переменная пути (Path variable) в списке переменных системного окружения (system environment variable) может быть назначена на обе версии, но с приоритетом одной из них, например 32-битной.
Получается, что, включая приглашение командной строки (command prompt), я использую 32-битную версию pip для установки модуля.
При запуске интегрированной среды разработки используеются 64-битная версия.
Если все произойдет вот так, то импортировать установленный модуль не получится.

В38. Отталкиваясь от предыдущего вопроса и ответа, как можно решить данную проблему?

Есть два варианта.

1. Временное решение. Можно добавлять путь вручную через sys перед каждым включением новой сессии интерпретатора (interpreter).

>>> sys.path.append('C:\\Users\\Ayushi\\AppData\\Local\\Programs\\Python\\Python37\\Scripts')
2. Постоянное решение. Обновить значение Path в переменных окружения, чтобы папка Scripts 64-битной версии была первой.

В39. Допустим, во время установки пакета (package) с помощью pip появляется ошибка "No matching installation found" (Подходящей установки не обнаружено). Что здесь можно сделать?

В такой ситуации можно, как вариант, загрузить исполняемые файлы пакета.

В40. Как можно отслеживать разные версии кода?

Для этого используется контроль версий (version control). Одним из возможных инструментов контроля является Git.

В41. Как можно провести отладку (debug) программы в Python? Дайте короткий ответ.

Для отладки в Python используется модуль pdb, отладчик (debugger) Python. Если запустить программу с pdb, то мы сможем пройти по коду пошагово.

В42. Можно ли осуществить динамическую загрузку модуля в Python?

При динамической загрузке модули загружаются только когда они становятся нужны. Такой подход — медленный, но он помогает эффективнее использовать память. В Python для этого можно использовать модуль importlib:

import importlib
module = importlib.import_module('my_package.my_module')
В43. Какие методы/функции мы используем для определения типа экземпляра (type of instance) и наследования (inheritance)?

Для этого используются type(), isinstance() и issubclass().

1. type() используется для определени типа объекта.

>>> type(3)
>>> type(False)
>>> type(lambda :print("Hi"))
>>> type(type)
2. isinstance() принимает два аргумента: значение (value) и тип (type). Если значение относится к соответствующему типу, то возвращается True. Если нет, то возвращается False.

>>> isinstance(3,int)
True
>>> isinstance((1),tuple)
False
>>> isinstance((1,),tuple)
True
3. issubclass() принимает два класса (classes) в качестве аргументов (arguments). Если второй наследует из первого, то возвращается True. Если нет, то возвращается False.

>>> class A: pass
>t; class B(A): pass
>>> issubclass(B,A)
True
>>> issubclass(A,B)
False
В44. Методы (methods) и конструкторы (constructors) — это одно и то же или нет?

Разница между ними очень тонкая, но важная:

Название конструктора должно соответствовать названию класса, а метод можно называть как угодно.
Конструктор исполняется при создании объекта, а метод исполняется при его вызове.
Конструктор исполняется один раз для каждого объекта, а метод можно вызывать по одному объекту неограниченно.
Конструкторы используются для определения (define) и инициализации не статических переменных. Методы используются для осуществления операций в рамках бизнес-логики.
В45. Что понимается под модулем в питоне?

Модуль — это скрипт, в котором определяются операторы импорта (import statements), функции (functions), классы (classes) и переменные (variables). Файлы ZIP и DLL тоже могут быть модулями. Название модуля хранится в глобальной переменной (global variable) в виде строки (string).

В46. Какие в питоне есть модули для работы с файлами?

Питон предлагает следующие библиотеки и модули для обработки текстов и двоичных файлов:

os
os.path
shutil

В47. Можете коротко объяснить, как используются модули sqlite3, ctypes, pickle, traceback и itertools.

sqlite3 помогает обрабатывать базы данных, например SQLite
ctypes позволяет создавать в питоне типы данных из Си и обрабатывать их
pickle позволяет переносить любые структуры данных во внешние файлы
traceback позволяет извлекать, форматировать и выводить на печать трассы вызовов (stack traces)
itertools помогает работать с перестановками (permutations), комбинациями (combinations) и другими итерируемыми объектами (iterables).
В48. Расскажите про наследование (inheritance) в Python.

Когда один класс наследует из другого, его называют дочерним/производным/подклассом (child/derived/sub class), который наследует из родительского/базового/супер класса (parent/base/super class). Он наследует/получает все атрибуты и методы.

Наследование позволяет повторно использовать код и облегчает создание и дальнейшую работу приложений (applications). В Python поддерживаются следующие виды наследования:

Единичное наследование (Single Inheritance) — класс наследует из одного базового класса.
Множественное наследование (Multiple Inheritance) — класс наследует из двух или нескольких базовых классов.
Многоуровневое наследование (Multilevel Inheritance) — класс наследует из базового класса, который, в свою очередь, наследует из другого базового класса.
Иерархическое наследование (Hierarchical Inheritance) — два класса или несколько классов наследуют из одного базового класса (single base class).
Гибридное наследование (Hybrid Inheritance) — сочетание двух или нескольких видов наследования.
В49. Объясните, как в Python осуществляется управление памятью.

В Python объекты и структуры данных (data structures) находятся в закрытой динамически выделяемой области (private heap), которая управляется менеджером памяти Python. Он делегирует часть работы программам распределения ресурсов (allocators), закрепленным за конкретными объектами, и одновременно с этим следит, чтобы они не выходили за пределы динамически выделяемой области. По факту данной областью управляет интерпретатор (interpreter). Пользователь никак не контролирует данный процесс, даже когда манипулирует ссылками объектов на блоки памяти внутри динаической области. Менеджер памяти Python распределяет пространство динамической области среди объектов и другие внутренние буферы по требованию.

В50. Напишите программу на питоне, которая посчитает количество заглавных букв в файле.

>>> import os
>>> os.chdir('C:\\Users\\lifei\\Desktop')
>>> with open('Today.txt') as today:
....count=0
for i in today.read():
....if i.isupper():
........count+=1
....print(count)
26
В51. Как можно сделать скрипт Python, исполняемый в Unix?

Для этого должны выполняться два условия:

Файл скрипта должен быть в исполняемом режиме.
Первая строка должен начинаться с решетки (хэша, hash(#)), например: #!/usr/local/bin/python
В52. Какие функции или методы можно использовать для удаления файла в Python?

Для этого можно использовать remove() или unlink().

>>> import os
>>> os.chdir('C:\\Users\\lifei\\Desktop')
>>> os.remove('try.py')
>>>
>>> os.unlink('try.py')
>>>
Обе функции делают одно и то же, просто unlink — это традиционное название в Unix.

В53. Можете написать функцию для генерации такой пирамиды?

*
***
*****
*******
*********

def pyramid(n):
    for row in range(n):
        for space in range(n-row):
            print(' ',end='')
    for star in range(row):
        print('*',end='')
    for star in range(row+1):
        print('*',end='')
    print()

pyramid(5)
В54. Как можно вывести на печать содержимое файла?

>>> try:
....with open('tabs.txt','r') as f:
........print(f.read())
....except IOError:
........print("File not found")
В55. Расскажите про выражения лямбда (lambda expressions). Где они могут пригодиться?

Если нужно написать функцию с одним выражением, то можно обойтись без определения и сделать ее анонимной. Выражение лямбда может принимать входные данные и возвращать значения. Пример функции, представленной в виде выражения лямбда:

>>> (lambda a,b:a if a>b else b)(3,3.5)
3.5
В данном примере входные данные обозначаются переменными a и b. То есть, если a > b, то возвращается a, в противном случае возвращается b. В качестве аргументов используются 3 и 3.5.

Лямбда позволяет обойтись без входных данных.

>>> (lambda :print("Hi"))()
Hi
В56. Что такое генератор (generator)?

В питоне генератор создает последовательность (sequence) значений, вдоль которой осуществляется итерация. То есть, это своего рода итерируемый объект (iterable). Мы пишем функцию, которая выдает (yield) значения по одному, а затем используем цикл for (for loop) для итерации вдоль нее.

def squares(n):
    i=1
    while(i<=n):
        yield i**2
    i+=1

>>> for i in squares(7):
....print(i)
1
4
9
16
25
36
49
В57. Ну тогда, что такое итератор (iterator)?

Итератор возвращает один объект за раз во время цикла итерации. Для создания итератора можно использовать функцию iter().

odds=iter([1,3,5,7,9])
Затем мы отправляем его в функцию next() каждый раз, когда хотим получить объект.

>>> next(odds)
1
>>> next(odds)
3
>>> next(odds)
5
>>> next(odds)
7
>>> next(odds)
9
Но при следующем вызове появится исключение остановки итерации (StopIteration exception), потому что закончили значения, по которым можно осуществлять итерацию.

>>> next(odds)
Traceback (most recent call last):
File “<pyshell#295>”, line 1, in
next(odds)
StopIteration
В58. Хорошо, мы спросили вас про генераторы (generators) и итераторы (iterators), и вы дали верные ответы. Но ведь они звучат очень похоже?

Так и есть, но между ними существуют тонкие различия:

Для генератора мы написали функцию, а для итератора можно использовать встроенные функции iter() и next().
Для генератора используется ключевое слово yield для выдачи по одному объекту за раз.
В генераторе может быть сколько угодно операторов yield.
Генератор сохраняет текущее состояние локальных переменных (local variables) каждый раз, когда yield приостанавливает цикл (loop). Итератор не использует локальные переменные, он работает только с итерируемым объектом (iterable).
Итератор можно использовать с помощью класса, а генератор — нет.
Генераторы работают быстро, компактно и проще.
Итераторы экономнее потребляют память.
В59. Что такое декоратор (decorator)?

Функция, которая расширяет другую функцию без внесения в нее изменений, оборачиваясь (wrap) вокруг нее. Посмотрим на примере.

>>> def decor(func):
....def wrap():
........print("$$$$$$$$$$$$$$$$$")
........func()
........print("$$$$$$$$$$$$$$$$$")
Декораторы — из сферы метапрограммирования (metaprogramming), в котором одна часть кода пытается изменить другую.

В60. Что такое временная подмена (Monkey Patching)?

Она модифицирует класс или модуль во время выполнения (at runtime), то есть представляет собой динамическую модификацию (dynamic modification). Пример:

from pkg.module import MyClass

def sayhello(self):
    print("Hello")

MyClass.sayhello=sayhello
Свободные вопросы, не связанные с техническими знаниями о Python.

Также следует быть готовым к вопросам на свободные темы, с помощью которых интевьюер хочет узнать получше ваш характер и ваши мотивации. Несколько примеров таких вопросов см. далее.

В61. Почему мы должны взять именно вас?

В62. В чем вы выросли как личность после ухода с последнего места?

В63. Расскажите про какую-нибудь ситуацию на прошлой работе, когда возникли сложности. Как вы их решили?

В64. Как бы вы урегулировали спор с коллегой? Возникали ли такие ситуации на прошлой работе?

В65. В чем бы вы хотели, чтобы мы были лучше по сравнению с прошлым работодателем?

В66. Удавалось ли вам когда-нибудь изменить чью-то позицию по рабочему вопросу?

В67. Что думаете про обмен слухами среди коллег?

В68. В чем ваше слабое место с точки зрения работы?

В69. Как вы думаете, в каком направлении будет развиваться отрасль в следующие 15 лет?

В70. Что вы оставили после себя на прошлой работе? Удалось ли вам развить инновационное решение?

В71. Как бы вы предпочли работать, самостоятельно или в небольшой/крупной группе?